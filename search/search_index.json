{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Safe Kit (Python)","text":"<p>A Python implementation of the Safe Protocol Kit, designed to mirror the developer experience of the official Node.js SDK.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>DX First: Intuitive API for interacting with Safe smart accounts.</li> <li>Type Safe: Built with Pydantic and fully typed for robust development.</li> <li>Modern Stack: Uses Web3.py, Eth-account, and Python 3.10+.</li> <li>Full Protocol Support: Supports Safe deployment, transaction creation, signing (EIP-712 &amp; eth_sign), and execution.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This project uses Poetry for dependency management.</p> <pre><code>pip install safe-kit\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add safe-kit\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#initialization","title":"Initialization","text":"<pre><code>from web3 import Web3\nfrom eth_account import Account\nfrom safe_kit.safe import Safe\nfrom safe_kit.adapter import Web3Adapter\n\n# Setup Web3 and Signer\nw3 = Web3(Web3.HTTPProvider(\"RPC_URL\"))\nowner = Account.from_key(\"PRIVATE_KEY\")\nadapter = Web3Adapter(web3=w3, signer=owner)\n\n# Initialize Safe\nsafe = Safe(eth_adapter=adapter, safe_address=\"0xSafeAddress\")\n</code></pre> <p>For more detailed usage, see the User Guide.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This document outlines the development roadmap for <code>safe-kit</code> and tracks its feature parity with the official Safe Protocol Kit.</p>"},{"location":"roadmap/#release-plan","title":"Release Plan","text":""},{"location":"roadmap/#v00x-alpha","title":"v0.0.x (Alpha)","text":"<p>Focus on implementing core functionalities and ensuring the library is usable for basic operations.</p> <ul> <li>v0.0.2 (Released): Basic Safe deployment, transaction creation, and execution.</li> <li>v0.0.3 (Released): MultiSend support (batching) and Safe Transaction Service integration.</li> <li>v0.0.4 (Released): Improved type safety, auto-generated types from ABIs, and CI/CD integration.</li> <li>v0.0.5 (Skipped): Implementation merged into v0.0.6.</li> <li>v0.0.6 (Released): Enhanced Safe Transaction Service client (history), Chain ID validation, and automated PyPI publishing.</li> <li>v0.0.7 (Released): Safe version awareness, extended service client queries, and improved address validation.</li> <li>v0.0.8 (Released): Extended Service Client with Safe info, creation info, collectibles (NFTs), and delegates management.</li> <li>v0.0.9 (Released): Extended Service Client with Token info and Data Decoding.</li> <li>v0.0.10 (In Progress): Message signing (EIP-191), Signature validation (EIP-1271), and robust transaction handling.</li> </ul>"},{"location":"roadmap/#v01x-beta","title":"v0.1.x (Beta)","text":"<p>Focus on stability, comprehensive testing, and developer experience improvements.</p> <ul> <li>v0.1.0: Full test coverage (including integration tests with local nodes), improved error handling, and documentation polish.</li> </ul>"},{"location":"roadmap/#v100-stable","title":"v1.0.0 (Stable)","text":"<p>Production-ready release with stable API and full feature parity.</p>"},{"location":"roadmap/#feature-parity-status","title":"Feature Parity Status","text":""},{"location":"roadmap/#1-safe-factory-deployment","title":"1. Safe Factory (Deployment)","text":"<p>Status: Implemented</p> <ul> <li>[x] <code>SafeFactory</code> Class: Create a factory class to handle Safe deployments.</li> <li>[x] <code>deploySafe</code>: Method to deploy a new Safe with initial configuration.</li> <li>[x] <code>predictSafeAddress</code>: Calculate counterfactual address.</li> <li>[x] Safe Proxy Factory: Integration with Safe Proxy Factory.</li> </ul>"},{"location":"roadmap/#2-safe-management","title":"2. Safe Management","text":"<p>Status: Implemented</p> <ul> <li>[x] Owner Management: Add, remove, and swap owners (<code>addOwnerWithThreshold</code>, etc.).</li> <li>[x] Threshold Management: Change signature threshold (<code>changeThreshold</code>).</li> </ul>"},{"location":"roadmap/#3-transaction-helpers","title":"3. Transaction Helpers","text":"<p>Status: Implemented</p> <ul> <li>[x] Transfers: ETH (<code>createNativeTransferTx</code>), ERC20 (<code>createERC20TransferTx</code>), ERC721 (<code>createERC721TransferTx</code>).</li> <li>[x] Modules: Enable/Disable modules (<code>createEnableModuleTx</code>, <code>createDisableModuleTx</code>).</li> <li>[x] Rejection: Cancel pending transactions (<code>createRejectionTx</code>).</li> </ul>"},{"location":"roadmap/#4-signatures-execution","title":"4. Signatures &amp; Execution","text":"<p>Status: Implemented</p> <ul> <li>[x] EIP-712 Signatures: Standard Safe signature format.</li> <li>[x] <code>eth_sign</code> Support: Legacy signature support.</li> <li>[x] EIP-191 Message Signing: Sign arbitrary messages (<code>sign_message</code>).</li> <li>[x] On-chain Approval: <code>approveHash</code> for smart contract wallets.</li> <li>[x] Signature Validation: Off-chain validation via <code>checkSignatures</code> and EIP-1271 (<code>isValidSignature</code>).</li> <li>[x] Gas Estimation: Automatic <code>safeTxGas</code> calculation.</li> </ul>"},{"location":"roadmap/#5-advanced-features","title":"5. Advanced Features","text":"<p>Status: Partially Implemented</p> <ul> <li>[x] Modules: Query enabled modules (<code>getModules</code>, <code>isModuleEnabled</code>).</li> <li>[x] Guards: Transaction guards (<code>getGuard</code>, <code>setGuardTx</code>).</li> <li>[x] Fallback Handler: Fallback handler management (<code>getFallbackHandler</code>, <code>setFallbackHandlerTx</code>).</li> <li>[x] MultiSend: Batch multiple transactions into one (Added in v0.0.3).</li> <li>[ ] Multi-version Support: Compatibility with older Safe versions (v1.0.0 - v1.2.0).</li> </ul>"},{"location":"roadmap/#6-service-integration","title":"6. Service Integration","text":"<p>Status: Implemented</p> <ul> <li>[x] Safe Transaction Service: Client for <code>propose_transaction</code>, <code>confirm_transaction</code>, etc. (Added in v0.0.3).</li> </ul>"},{"location":"roadmap/#7-infrastructure-dx","title":"7. Infrastructure &amp; DX","text":"<p>Status: In Progress</p> <ul> <li>[x] Error Handling: Readable Python exceptions for EVM reverts.</li> <li>[x] Type Generation: Auto-generate Python types from Safe ABIs.</li> <li>[x] CI/CD: Automated linting, testing, and type checking.</li> <li>[ ] Chain ID Handling: Better support for EIP-155.</li> <li>[ ] Automated Publishing: Publish to PyPI on release.</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":""},{"location":"user_guide/#initialization","title":"Initialization","text":"<p>To start using Safe Kit, you need to initialize a <code>Safe</code> instance. This requires a <code>Web3Adapter</code> which connects to an Ethereum node and handles signing.</p> <pre><code>from web3 import Web3\nfrom eth_account import Account\nfrom safe_kit.safe import Safe\nfrom safe_kit.adapter import Web3Adapter\n\n# Setup Web3 and Signer\nw3 = Web3(Web3.HTTPProvider(\"RPC_URL\"))\nowner = Account.from_key(\"PRIVATE_KEY\")\nadapter = Web3Adapter(web3=w3, signer=owner)\n\n# Initialize Safe\nsafe = Safe(eth_adapter=adapter, safe_address=\"0xSafeAddress\")\n</code></pre>"},{"location":"user_guide/#creating-and-signing-transactions","title":"Creating and Signing Transactions","text":"<p>You can create transactions to send assets or interact with other contracts.</p> <pre><code>from safe_kit.types import SafeTransactionData\n\n# Create a transaction (e.g., send ETH)\ntx_data = SafeTransactionData(\n    to=\"0xRecipient\",\n    value=1000000000000000000, # 1 ETH\n    data=\"0x\"\n)\n\nsafe_tx = safe.create_transaction(tx_data)\n\n# Sign the transaction\n# Supports \"eth_sign_typed_data\" (default, EIP-712) or \"eth_sign\" (legacy)\nsigned_tx = safe.sign_transaction(safe_tx)\n</code></pre>"},{"location":"user_guide/#executing-transactions","title":"Executing Transactions","text":"<p>Once a transaction has enough signatures (based on the Safe's threshold), it can be executed.</p> <pre><code># Execute the transaction on-chain\ntx_hash = safe.execute_transaction(signed_tx)\nprint(f\"Transaction executed: {tx_hash}\")\n</code></pre>"},{"location":"user_guide/#batching-transactions-multisend","title":"Batching Transactions (MultiSend)","text":"<p>You can batch multiple transactions into a single on-chain transaction using <code>MultiSend</code>.</p> <pre><code>from safe_kit.types import SafeTransactionData\n\n# Define multiple transactions\ntx1 = SafeTransactionData(to=\"0xRecipient1\", value=100, data=\"0x\")\ntx2 = SafeTransactionData(to=\"0xRecipient2\", value=200, data=\"0x\")\n\n# Create a MultiSend transaction\n# You need the address of the MultiSend contract on your chain\nmulti_send_address = \"0x...\" \nmulti_send_tx = safe.create_multi_send_transaction([tx1, tx2], multi_send_address)\n\n# Sign and execute as usual\nsigned_tx = safe.sign_transaction(multi_send_tx)\ntx_hash = safe.execute_transaction(signed_tx)\n</code></pre>"},{"location":"user_guide/#using-safe-transaction-service","title":"Using Safe Transaction Service","text":"<p>You can interact with the Safe Transaction Service to propose transactions for other owners to sign.</p> <pre><code>from safe_kit.service import SafeServiceClient\n\nclient = SafeServiceClient(\"https://safe-transaction-mainnet.safe.global\")\n\n# 1. Propose a transaction\nsafe_tx_hash = safe.get_transaction_hash(signed_tx)\nclient.propose_transaction(\n    safe_address=safe.safe_address,\n    safe_tx_data=signed_tx.data,\n    safe_tx_hash=safe_tx_hash,\n    sender_address=owner.address,\n    signature=signed_tx.signatures[owner.address].data.hex()\n)\n\n# 2. Get pending transactions\npending_txs = client.get_pending_transactions(safe.safe_address)\n\n# 3. Confirm (sign) a pending transaction\n# Assume you are a different owner now\nclient.confirm_transaction(safe_tx_hash, new_signature)\n</code></pre>"},{"location":"user_guide/#deploying-a-safe-with-custom-modules","title":"Deploying a Safe with Custom Modules","text":"<p>You can deploy a new Safe and enable modules during deployment.</p> <pre><code>from safe_kit.factory import SafeFactory\nfrom safe_kit.types import SafeAccountConfig\n\nfactory = SafeFactory(\n    eth_adapter=adapter,\n    safe_singleton_address=\"0x...\",\n    safe_proxy_factory_address=\"0x...\"\n)\n\n# To enable a module during deployment, you would typically use a \"setup\" call\n# encoded in the `data` field of SafeAccountConfig.\n# However, a simpler way is to deploy first, then enable the module.\n\n# 1. Deploy Safe\nconfig = SafeAccountConfig(\n    owners=[owner.address],\n    threshold=1\n)\nsafe = factory.deploy_safe(config)\nprint(f\"Deployed Safe at: {safe.safe_address}\")\n\n# 2. Enable Module\nmodule_address = \"0xModuleAddress\"\nenable_tx = safe.create_enable_module_transaction(module_address)\nsigned_tx = safe.sign_transaction(enable_tx)\ntx_hash = safe.execute_transaction(signed_tx)\nprint(f\"Module enabled: {tx_hash}\")\n</code></pre>"},{"location":"api/adapter/","title":"Adapter","text":""},{"location":"api/adapter/#safe_kit.adapter","title":"<code>safe_kit.adapter</code>","text":""},{"location":"api/adapter/#safe_kit.adapter.EthAdapter","title":"<code>EthAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Ethereum adapters.</p> Source code in <code>safe_kit/adapter.py</code> <pre><code>class EthAdapter(ABC):\n    \"\"\"\n    Abstract base class for Ethereum adapters.\n    \"\"\"\n\n    @abstractmethod\n    def get_balance(self, address: str) -&gt; int:\n        pass\n\n    @abstractmethod\n    def get_chain_id(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def get_safe_contract(self, safe_address: str) -&gt; Any:\n        pass\n\n    @abstractmethod\n    def get_contract(self, address: str, abi: list[Any]) -&gt; Any:\n        pass\n\n    @abstractmethod\n    def get_signer_address(self) -&gt; str | None:\n        pass\n\n    @abstractmethod\n    def sign_message(self, message: str) -&gt; str:\n        pass\n\n    @abstractmethod\n    def sign_typed_data(self, data: dict[str, Any]) -&gt; str:\n        pass\n\n    @abstractmethod\n    def get_storage_at(self, address: str, position: int) -&gt; bytes:\n        pass\n\n    @abstractmethod\n    def get_code(self, address: str) -&gt; bytes:\n        pass\n\n    @abstractmethod\n    def get_transaction_count(self, address: str) -&gt; int:\n        pass\n\n    @abstractmethod\n    def is_contract(self, address: str) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def to_checksum_address(self, address: str) -&gt; str:\n        pass\n\n    @abstractmethod\n    def wait_for_transaction_receipt(self, tx_hash: str, timeout: int = 120) -&gt; Any:\n        pass\n</code></pre>"},{"location":"api/adapter/#safe_kit.adapter.Web3Adapter","title":"<code>Web3Adapter</code>","text":"<p>               Bases: <code>EthAdapter</code></p> <p>Web3.py implementation of the EthAdapter.</p> Source code in <code>safe_kit/adapter.py</code> <pre><code>class Web3Adapter(EthAdapter):\n    \"\"\"\n    Web3.py implementation of the EthAdapter.\n    \"\"\"\n\n    def __init__(self, web3: Web3, signer: LocalAccount | None = None):\n        self.web3 = web3\n        self.signer = signer\n\n    def get_balance(self, address: str) -&gt; int:\n        return self.web3.eth.get_balance(self.web3.to_checksum_address(address))\n\n    def get_chain_id(self) -&gt; int:\n        return self.web3.eth.chain_id\n\n    def get_safe_contract(self, safe_address: str) -&gt; Any:\n        from safe_kit.abis import SAFE_ABI\n\n        return self.web3.eth.contract(\n            address=self.web3.to_checksum_address(safe_address), abi=SAFE_ABI\n        )\n\n    def get_contract(self, address: str, abi: list[Any]) -&gt; Any:\n        return self.web3.eth.contract(\n            address=self.web3.to_checksum_address(address), abi=abi\n        )\n\n    def get_signer_address(self) -&gt; str | None:\n        if self.signer:\n            return str(self.signer.address)\n        return None\n\n    def sign_message(self, message: str | bytes) -&gt; str:\n        if not self.signer:\n            raise ValueError(\"No signer available\")\n\n        from eth_account.messages import encode_defunct\n\n        if isinstance(message, bytes):\n            signable_message = encode_defunct(primitive=message)\n        elif message.startswith(\"0x\"):\n            signable_message = encode_defunct(hexstr=message)\n        else:\n            signable_message = encode_defunct(text=message)\n\n        signed_message = self.signer.sign_message(signable_message)  # type: ignore[no-untyped-call]\n        return str(signed_message.signature.hex())\n\n    def sign_typed_data(self, data: dict[str, Any]) -&gt; str:\n        if not self.signer:\n            raise ValueError(\"No signer available\")\n        from eth_account.messages import encode_typed_data\n\n        signable_message = encode_typed_data(full_message=data)\n        signed_message = self.signer.sign_message(signable_message)  # type: ignore[no-untyped-call]\n        return str(signed_message.signature.hex())\n\n    def get_storage_at(self, address: str, position: int) -&gt; bytes:\n        return self.web3.eth.get_storage_at(\n            self.web3.to_checksum_address(address), position\n        )\n\n    def get_code(self, address: str) -&gt; bytes:\n        return self.web3.eth.get_code(self.web3.to_checksum_address(address))\n\n    def get_transaction_count(self, address: str) -&gt; int:\n        return self.web3.eth.get_transaction_count(\n            self.web3.to_checksum_address(address)\n        )\n\n    def is_contract(self, address: str) -&gt; bool:\n        code = self.get_code(address)\n        return len(code) &gt; 0\n\n    def to_checksum_address(self, address: str) -&gt; str:\n        return self.web3.to_checksum_address(address)\n\n    def wait_for_transaction_receipt(self, tx_hash: str, timeout: int = 120) -&gt; Any:\n        from hexbytes import HexBytes\n\n        return self.web3.eth.wait_for_transaction_receipt(\n            HexBytes(tx_hash), timeout=timeout\n        )\n</code></pre>"},{"location":"api/factory/","title":"Factory","text":""},{"location":"api/factory/#safe_kit.factory","title":"<code>safe_kit.factory</code>","text":""},{"location":"api/factory/#safe_kit.factory.SafeFactory","title":"<code>SafeFactory</code>","text":"<p>Factory class to deploy new Safe contracts.</p> Source code in <code>safe_kit/factory.py</code> <pre><code>class SafeFactory:\n    \"\"\"\n    Factory class to deploy new Safe contracts.\n    \"\"\"\n\n    def __init__(\n        self,\n        eth_adapter: EthAdapter,\n        safe_singleton_address: str,\n        safe_proxy_factory_address: str,\n    ):\n        self.eth_adapter = eth_adapter\n        self.safe_singleton_address = safe_singleton_address\n        self.safe_proxy_factory_address = safe_proxy_factory_address\n        self.proxy_factory_contract = self.eth_adapter.get_contract(\n            address=safe_proxy_factory_address, abi=SAFE_PROXY_FACTORY_ABI\n        )\n\n    def _get_initializer_data(self, config: SafeAccountConfig) -&gt; bytes:\n        safe_singleton = self.eth_adapter.get_safe_contract(self.safe_singleton_address)\n        return cast(\n            bytes,\n            safe_singleton.encodeABI(\n                fn_name=\"setup\",\n                args=[\n                    config.owners,\n                    config.threshold,\n                    config.to,\n                    HexBytes(config.data),\n                    config.fallback_handler,\n                    config.payment_token,\n                    config.payment,\n                    config.payment_receiver,\n                ],\n            ),\n        )\n\n    def predict_safe_address(\n        self, config: SafeAccountConfig, salt_nonce: int = 0\n    ) -&gt; str:\n        \"\"\"\n        Predicts the address of the Safe that would be deployed with the given\n        configuration.\n        \"\"\"\n        initializer = self._get_initializer_data(config)\n        params: SafeProxyFactoryCreateProxyWithNonceParams = {\n            \"_singleton\": self.safe_singleton_address,\n            \"initializer\": initializer,\n            \"saltNonce\": salt_nonce,\n        }\n        return cast(\n            str,\n            self.proxy_factory_contract.functions.createProxyWithNonce(**params).call(),\n        )\n\n    def predict_safe_address_v1_4_1(\n        self, config: SafeAccountConfig, salt_nonce: int = 0\n    ) -&gt; str:\n        \"\"\"\n        Predicts the address of the Safe (v1.4.1) that would be deployed.\n        Uses createChainSpecificProxyWithNonce.\n        \"\"\"\n        initializer = self._get_initializer_data(config)\n        params: SafeProxyFactoryCreateChainSpecificProxyWithNonceParams = {\n            \"_singleton\": self.safe_singleton_address,\n            \"initializer\": initializer,\n            \"saltNonce\": salt_nonce,\n        }\n        return cast(\n            str,\n            self.proxy_factory_contract.functions.createChainSpecificProxyWithNonce(\n                **params\n            ).call(),\n        )\n\n    def deploy_safe(self, config: SafeAccountConfig, salt_nonce: int = 0) -&gt; Safe:\n        \"\"\"\n        Deploys a new Safe contract.\n        Returns a Safe instance with the predicted address.\n        \"\"\"\n        signer = self.eth_adapter.get_signer_address()\n        if not signer:\n            raise ValueError(\"No signer configured in the adapter\")\n\n        initializer = self._get_initializer_data(config)\n        safe_address = self.predict_safe_address(config, salt_nonce)\n\n        try:\n            params: SafeProxyFactoryCreateProxyWithNonceParams = {\n                \"_singleton\": self.safe_singleton_address,\n                \"initializer\": initializer,\n                \"saltNonce\": salt_nonce,\n            }\n            self.proxy_factory_contract.functions.createProxyWithNonce(\n                **params\n            ).transact({\"from\": signer})\n        except Exception as e:\n            raise handle_contract_error(e) from e\n\n        return Safe(self.eth_adapter, safe_address)\n\n    def deploy_safe_v1_4_1(\n        self, config: SafeAccountConfig, salt_nonce: int = 0\n    ) -&gt; Safe:\n        \"\"\"\n        Deploys a new Safe contract (v1.4.1).\n        Returns a Safe instance with the predicted address.\n        \"\"\"\n        signer = self.eth_adapter.get_signer_address()\n        if not signer:\n            raise ValueError(\"No signer configured in the adapter\")\n\n        initializer = self._get_initializer_data(config)\n        safe_address = self.predict_safe_address_v1_4_1(config, salt_nonce)\n\n        try:\n            params: SafeProxyFactoryCreateChainSpecificProxyWithNonceParams = {\n                \"_singleton\": self.safe_singleton_address,\n                \"initializer\": initializer,\n                \"saltNonce\": salt_nonce,\n            }\n            self.proxy_factory_contract.functions.createChainSpecificProxyWithNonce(\n                **params\n            ).transact({\"from\": signer})\n        except Exception as e:\n            raise handle_contract_error(e) from e\n\n        return Safe(self.eth_adapter, safe_address)\n</code></pre>"},{"location":"api/factory/#safe_kit.factory.SafeFactory.deploy_safe","title":"<code>deploy_safe(config, salt_nonce=0)</code>","text":"<p>Deploys a new Safe contract. Returns a Safe instance with the predicted address.</p> Source code in <code>safe_kit/factory.py</code> <pre><code>def deploy_safe(self, config: SafeAccountConfig, salt_nonce: int = 0) -&gt; Safe:\n    \"\"\"\n    Deploys a new Safe contract.\n    Returns a Safe instance with the predicted address.\n    \"\"\"\n    signer = self.eth_adapter.get_signer_address()\n    if not signer:\n        raise ValueError(\"No signer configured in the adapter\")\n\n    initializer = self._get_initializer_data(config)\n    safe_address = self.predict_safe_address(config, salt_nonce)\n\n    try:\n        params: SafeProxyFactoryCreateProxyWithNonceParams = {\n            \"_singleton\": self.safe_singleton_address,\n            \"initializer\": initializer,\n            \"saltNonce\": salt_nonce,\n        }\n        self.proxy_factory_contract.functions.createProxyWithNonce(\n            **params\n        ).transact({\"from\": signer})\n    except Exception as e:\n        raise handle_contract_error(e) from e\n\n    return Safe(self.eth_adapter, safe_address)\n</code></pre>"},{"location":"api/factory/#safe_kit.factory.SafeFactory.deploy_safe_v1_4_1","title":"<code>deploy_safe_v1_4_1(config, salt_nonce=0)</code>","text":"<p>Deploys a new Safe contract (v1.4.1). Returns a Safe instance with the predicted address.</p> Source code in <code>safe_kit/factory.py</code> <pre><code>def deploy_safe_v1_4_1(\n    self, config: SafeAccountConfig, salt_nonce: int = 0\n) -&gt; Safe:\n    \"\"\"\n    Deploys a new Safe contract (v1.4.1).\n    Returns a Safe instance with the predicted address.\n    \"\"\"\n    signer = self.eth_adapter.get_signer_address()\n    if not signer:\n        raise ValueError(\"No signer configured in the adapter\")\n\n    initializer = self._get_initializer_data(config)\n    safe_address = self.predict_safe_address_v1_4_1(config, salt_nonce)\n\n    try:\n        params: SafeProxyFactoryCreateChainSpecificProxyWithNonceParams = {\n            \"_singleton\": self.safe_singleton_address,\n            \"initializer\": initializer,\n            \"saltNonce\": salt_nonce,\n        }\n        self.proxy_factory_contract.functions.createChainSpecificProxyWithNonce(\n            **params\n        ).transact({\"from\": signer})\n    except Exception as e:\n        raise handle_contract_error(e) from e\n\n    return Safe(self.eth_adapter, safe_address)\n</code></pre>"},{"location":"api/factory/#safe_kit.factory.SafeFactory.predict_safe_address","title":"<code>predict_safe_address(config, salt_nonce=0)</code>","text":"<p>Predicts the address of the Safe that would be deployed with the given configuration.</p> Source code in <code>safe_kit/factory.py</code> <pre><code>def predict_safe_address(\n    self, config: SafeAccountConfig, salt_nonce: int = 0\n) -&gt; str:\n    \"\"\"\n    Predicts the address of the Safe that would be deployed with the given\n    configuration.\n    \"\"\"\n    initializer = self._get_initializer_data(config)\n    params: SafeProxyFactoryCreateProxyWithNonceParams = {\n        \"_singleton\": self.safe_singleton_address,\n        \"initializer\": initializer,\n        \"saltNonce\": salt_nonce,\n    }\n    return cast(\n        str,\n        self.proxy_factory_contract.functions.createProxyWithNonce(**params).call(),\n    )\n</code></pre>"},{"location":"api/factory/#safe_kit.factory.SafeFactory.predict_safe_address_v1_4_1","title":"<code>predict_safe_address_v1_4_1(config, salt_nonce=0)</code>","text":"<p>Predicts the address of the Safe (v1.4.1) that would be deployed. Uses createChainSpecificProxyWithNonce.</p> Source code in <code>safe_kit/factory.py</code> <pre><code>def predict_safe_address_v1_4_1(\n    self, config: SafeAccountConfig, salt_nonce: int = 0\n) -&gt; str:\n    \"\"\"\n    Predicts the address of the Safe (v1.4.1) that would be deployed.\n    Uses createChainSpecificProxyWithNonce.\n    \"\"\"\n    initializer = self._get_initializer_data(config)\n    params: SafeProxyFactoryCreateChainSpecificProxyWithNonceParams = {\n        \"_singleton\": self.safe_singleton_address,\n        \"initializer\": initializer,\n        \"saltNonce\": salt_nonce,\n    }\n    return cast(\n        str,\n        self.proxy_factory_contract.functions.createChainSpecificProxyWithNonce(\n            **params\n        ).call(),\n    )\n</code></pre>"},{"location":"api/safe/","title":"Safe","text":""},{"location":"api/safe/#safe_kit.safe","title":"<code>safe_kit.safe</code>","text":""},{"location":"api/safe/#safe_kit.safe.Safe","title":"<code>Safe</code>","text":"<p>               Bases: <code>OwnerManagerMixin</code>, <code>ModuleManagerMixin</code>, <code>TokenManagerMixin</code>, <code>GuardManagerMixin</code></p> <p>The main class for interacting with a Safe.</p> <p>This class provides a comprehensive interface for Safe operations including: - Basic Safe info (address, version, balance, nonce, threshold, owners) - Transaction creation, signing, and execution - Owner management (add, remove, swap owners, change threshold) - Module management (enable, disable, list modules) - Token transfers (ERC20, ERC721, native ETH) - Guard and fallback handler management</p> Source code in <code>safe_kit/safe.py</code> <pre><code>class Safe(\n    OwnerManagerMixin,\n    ModuleManagerMixin,\n    TokenManagerMixin,\n    GuardManagerMixin,\n):\n    \"\"\"\n    The main class for interacting with a Safe.\n\n    This class provides a comprehensive interface for Safe operations including:\n    - Basic Safe info (address, version, balance, nonce, threshold, owners)\n    - Transaction creation, signing, and execution\n    - Owner management (add, remove, swap owners, change threshold)\n    - Module management (enable, disable, list modules)\n    - Token transfers (ERC20, ERC721, native ETH)\n    - Guard and fallback handler management\n    \"\"\"\n\n    def __init__(\n        self, eth_adapter: EthAdapter, safe_address: str, chain_id: int | None = None\n    ):\n        self.eth_adapter = eth_adapter\n        self.safe_address = self.eth_adapter.to_checksum_address(safe_address)\n\n        if not self.eth_adapter.is_contract(self.safe_address):\n            raise ValueError(f\"Address {self.safe_address} is not a contract\")\n\n        self.contract = self.eth_adapter.get_safe_contract(self.safe_address)\n        self.chain_id = chain_id\n\n        if self.chain_id is not None:\n            adapter_chain_id = self.eth_adapter.get_chain_id()\n            if adapter_chain_id != self.chain_id:\n                raise ValueError(\n                    f\"Adapter chain ID ({adapter_chain_id}) does not match \"\n                    f\"Safe chain ID ({self.chain_id})\"\n                )\n\n    @classmethod\n    def create(\n        cls, eth_adapter: EthAdapter, safe_address: str, chain_id: int | None = None\n    ) -&gt; \"Safe\":\n        \"\"\"\n        Factory method to create a Safe instance.\n        \"\"\"\n        return cls(eth_adapter, safe_address, chain_id)\n\n    def get_address(self) -&gt; str:\n        \"\"\"\n        Returns the address of the Safe.\n        \"\"\"\n        return self.safe_address\n\n    def get_version(self) -&gt; str:\n        \"\"\"\n        Returns the version of the Safe contract.\n        \"\"\"\n        return cast(str, self.contract.functions.VERSION().call())\n\n    def get_balance(self) -&gt; int:\n        \"\"\"\n        Returns the ETH balance of the Safe.\n        \"\"\"\n        return self.eth_adapter.get_balance(self.safe_address)\n\n    def get_nonce(self) -&gt; int:\n        \"\"\"\n        Returns the current nonce of the Safe.\n        \"\"\"\n        return cast(int, self.contract.functions.nonce().call())\n\n    def get_threshold(self) -&gt; int:\n        \"\"\"\n        Returns the threshold of the Safe.\n        \"\"\"\n        return cast(int, self.contract.functions.getThreshold().call())\n\n    def get_owners(self) -&gt; list[str]:\n        \"\"\"\n        Returns the owners of the Safe.\n        \"\"\"\n        return cast(list[str], self.contract.functions.getOwners().call())\n\n    def is_owner(self, address: str) -&gt; bool:\n        \"\"\"\n        Checks if an address is an owner of the Safe.\n        \"\"\"\n        params: SafeIsOwnerParams = {\"owner\": address}\n        return cast(bool, self.contract.functions.isOwner(**params).call())\n\n    def create_transaction(\n        self, transaction_data: SafeTransactionData\n    ) -&gt; SafeTransaction:\n        \"\"\"\n        Creates a Safe transaction ready to be signed.\n        \"\"\"\n        if transaction_data.nonce is None:\n            transaction_data.nonce = self.get_nonce()\n\n        return SafeTransaction(data=transaction_data)\n\n    def sign_transaction(\n        self, safe_transaction: SafeTransaction, method: str = \"eth_sign_typed_data\"\n    ) -&gt; SafeTransaction:\n        \"\"\"\n        Signs a Safe transaction with the current signer.\n        Supported methods: \"eth_sign_typed_data\" (EIP-712), \"eth_sign\" (legacy).\n        \"\"\"\n        signer_address = self.eth_adapter.get_signer_address()\n        if not signer_address:\n            raise ValueError(\"No signer configured in the adapter\")\n\n        chain_id = self.eth_adapter.get_chain_id()\n\n        if method == \"eth_sign_typed_data\":\n            eip712_data = safe_transaction.data.get_eip712_data(\n                chain_id, self.safe_address\n            )\n            signature = self.eth_adapter.sign_typed_data(eip712_data)\n        elif method == \"eth_sign\":\n            tx_hash = self.get_transaction_hash(safe_transaction)\n            signature = self.eth_adapter.sign_message(tx_hash)\n            # Adjust v for eth_sign: v += 4\n            # Signature is r(32) + s(32) + v(1)\n            # We need to parse it, adjust v, and reconstruct\n            sig_bytes = HexBytes(signature)\n            r = sig_bytes[:32]\n            s = sig_bytes[32:64]\n            v = sig_bytes[64]\n            v += 4\n            signature = (r + s + bytes([v])).hex()\n        else:\n            raise ValueError(f\"Unsupported signing method: {method}\")\n\n        safe_transaction.add_signature(signer_address, signature)\n        return safe_transaction\n\n    def add_signature(\n        self, safe_transaction: SafeTransaction, owner_address: str, signature: str\n    ) -&gt; SafeTransaction:\n        \"\"\"\n        Adds a signature to a Safe transaction.\n        \"\"\"\n        owner_address = self.eth_adapter.to_checksum_address(owner_address)\n        safe_transaction.add_signature(owner_address, signature)\n        return safe_transaction\n\n    def add_prevalidated_signature(\n        self, safe_transaction: SafeTransaction, owner_address: str\n    ) -&gt; SafeTransaction:\n        \"\"\"\n        Adds a pre-validated signature for a given owner.\n        v=1, r=owner, s=0.\n        \"\"\"\n        owner_address = self.eth_adapter.to_checksum_address(owner_address)\n        # Signature: r(32) + s(32) + v(1)\n        # r = owner address, padded to 32 bytes\n        # s = 0, padded to 32 bytes\n        # v = 1\n        r = owner_address.lower().replace(\"0x\", \"\").zfill(64)\n        s = \"0\" * 64\n        v = \"01\"\n        signature = \"0x\" + r + s + v\n        safe_transaction.add_signature(owner_address, signature)\n        return safe_transaction\n\n    def get_transaction_hash(self, safe_transaction: SafeTransaction) -&gt; str:\n        \"\"\"\n        Returns the hash of the Safe transaction.\n        \"\"\"\n        params: SafeGetTransactionHashParams = {\n            \"to\": safe_transaction.data.to,\n            \"value\": safe_transaction.data.value,\n            \"data\": HexBytes(safe_transaction.data.data),\n            \"operation\": safe_transaction.data.operation,\n            \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n            \"baseGas\": safe_transaction.data.base_gas,\n            \"gasPrice\": safe_transaction.data.gas_price,\n            \"gasToken\": safe_transaction.data.gas_token,\n            \"refundReceiver\": safe_transaction.data.refund_receiver,\n            \"_nonce\": (\n                safe_transaction.data.nonce\n                if safe_transaction.data.nonce is not None\n                else 0\n            ),\n        }\n\n        return cast(\n            str,\n            self.contract.functions.getTransactionHash(**params).call().hex(),\n        )\n\n    def approve_hash(self, hash_to_approve: str) -&gt; str:\n        \"\"\"\n        Approves a hash on-chain.\n        \"\"\"\n        try:\n            params: SafeApproveHashParams = {\"hashToApprove\": HexBytes(hash_to_approve)}\n            tx_hash = self.contract.functions.approveHash(**params).transact(\n                {\"from\": self.eth_adapter.get_signer_address()}\n            )\n            return cast(str, tx_hash.hex())\n        except Exception as e:\n            raise handle_contract_error(e) from e\n\n    def execute_transaction(\n        self,\n        safe_transaction: SafeTransaction,\n        wait_for_receipt: bool = False,\n        gas: int | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Executes a Safe transaction.\n        \"\"\"\n        # Sort signatures\n        sorted_signatures = safe_transaction.sorted_signatures_bytes\n\n        try:\n            params: SafeExecTransactionParams = {\n                \"to\": safe_transaction.data.to,\n                \"value\": safe_transaction.data.value,\n                \"data\": HexBytes(safe_transaction.data.data),\n                \"operation\": safe_transaction.data.operation,\n                \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n                \"baseGas\": safe_transaction.data.base_gas,\n                \"gasPrice\": safe_transaction.data.gas_price,\n                \"gasToken\": safe_transaction.data.gas_token,\n                \"refundReceiver\": safe_transaction.data.refund_receiver,\n                \"signatures\": sorted_signatures,\n            }\n\n            tx_params: dict[str, Any] = {\"from\": self.eth_adapter.get_signer_address()}\n            if gas is not None:\n                tx_params[\"gas\"] = gas\n\n            tx_hash_hex = self.contract.functions.execTransaction(**params).transact(\n                tx_params\n            )\n\n            tx_hash = cast(str, tx_hash_hex.hex())\n\n            if wait_for_receipt:\n                self.wait_for_transaction(tx_hash)\n\n            return tx_hash\n        except Exception as e:\n            raise handle_contract_error(e) from e\n\n    def simulate_transaction(self, safe_transaction: SafeTransaction) -&gt; bool:\n        \"\"\"\n        Simulates the transaction using eth_call.\n        Returns True if the transaction would succeed, False otherwise.\n        \"\"\"\n        try:\n            params: SafeExecTransactionParams = {\n                \"to\": safe_transaction.data.to,\n                \"value\": safe_transaction.data.value,\n                \"data\": HexBytes(safe_transaction.data.data),\n                \"operation\": safe_transaction.data.operation,\n                \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n                \"baseGas\": safe_transaction.data.base_gas,\n                \"gasPrice\": safe_transaction.data.gas_price,\n                \"gasToken\": safe_transaction.data.gas_token,\n                \"refundReceiver\": safe_transaction.data.refund_receiver,\n                \"signatures\": safe_transaction.sorted_signatures_bytes,\n            }\n\n            # Use call() to simulate\n            success = self.contract.functions.execTransaction(**params).call(\n                {\"from\": self.eth_adapter.get_signer_address()}\n            )\n\n            return cast(bool, success)\n        except Exception:\n            return False\n\n    def estimate_transaction_gas(self, safe_transaction: SafeTransaction) -&gt; int:\n        \"\"\"\n        Estimates the internal gas required for a Safe transaction (safeTxGas).\n        Uses the Safe contract's requiredTxGas function.\n        \"\"\"\n        params: SafeRequiredTxGasParams = {\n            \"to\": safe_transaction.data.to,\n            \"value\": safe_transaction.data.value,\n            \"data\": HexBytes(safe_transaction.data.data),\n            \"operation\": safe_transaction.data.operation,\n            \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n            \"baseGas\": safe_transaction.data.base_gas,\n            \"gasPrice\": safe_transaction.data.gas_price,\n            \"gasToken\": safe_transaction.data.gas_token,\n            \"refundReceiver\": safe_transaction.data.refund_receiver,\n            \"signatures\": safe_transaction.sorted_signatures_bytes,\n        }\n        return cast(\n            int,\n            self.contract.functions.requiredTxGas(**params).call(),\n        )\n\n    def estimate_safe_transaction_gas(self, safe_transaction: SafeTransaction) -&gt; int:\n        \"\"\"\n        Estimates the total gas (ETH gas) required to execute the Safe transaction.\n        Uses eth_estimateGas on the execTransaction function.\n        \"\"\"\n        params: SafeExecTransactionParams = {\n            \"to\": safe_transaction.data.to,\n            \"value\": safe_transaction.data.value,\n            \"data\": HexBytes(safe_transaction.data.data),\n            \"operation\": safe_transaction.data.operation,\n            \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n            \"baseGas\": safe_transaction.data.base_gas,\n            \"gasPrice\": safe_transaction.data.gas_price,\n            \"gasToken\": safe_transaction.data.gas_token,\n            \"refundReceiver\": safe_transaction.data.refund_receiver,\n            \"signatures\": safe_transaction.sorted_signatures_bytes,\n        }\n\n        return cast(\n            int,\n            self.contract.functions.execTransaction(**params).estimate_gas(\n                {\"from\": self.eth_adapter.get_signer_address()}\n            ),\n        )\n\n    def check_signatures(self, safe_transaction: SafeTransaction) -&gt; None:\n        \"\"\"\n        Checks if the signatures on the transaction are valid.\n        Raises an error if signatures are invalid.\n        \"\"\"\n        tx_hash = self.get_transaction_hash(safe_transaction)\n        # Convert hex string hash to bytes\n        tx_hash_bytes = HexBytes(tx_hash)\n\n        self.contract.functions.checkSignatures(\n            tx_hash_bytes,\n            HexBytes(safe_transaction.data.data),\n            safe_transaction.sorted_signatures_bytes,\n        ).call()\n\n    def wait_for_transaction(self, tx_hash: str, timeout: int = 120) -&gt; Any:\n        \"\"\"\n        Waits for a transaction receipt.\n        \"\"\"\n        return self.eth_adapter.wait_for_transaction_receipt(tx_hash, timeout=timeout)\n\n    def get_domain_separator(self) -&gt; str:\n        \"\"\"\n        Returns the EIP-712 domain separator of the Safe.\n        \"\"\"\n        return cast(str, self.contract.functions.domainSeparator().call().hex())\n\n    def get_message_hash(self, message: str | bytes) -&gt; str:\n        \"\"\"\n        Returns the safe message hash for a given message.\n        \"\"\"\n        if isinstance(message, str):\n            if message.startswith(\"0x\"):\n                message_bytes = HexBytes(message)\n            else:\n                message_bytes = HexBytes(message.encode(\"utf-8\"))\n        elif isinstance(message, bytes):\n            message_bytes = HexBytes(message)\n        else:\n            raise TypeError(\"message must be str or bytes\")\n\n        # keccak256(message)\n        from eth_hash.auto import keccak\n\n        message_hash = keccak(message_bytes)\n\n        result = self.contract.functions.getMessageHash(message_hash).call().hex()\n        if not result.startswith(\"0x\"):\n            result = \"0x\" + result\n        return cast(str, result)\n\n    def sign_message(self, message: str | bytes) -&gt; str:\n        \"\"\"\n        Signs a message hash using the current signer.\n        Returns the signature using eth_sign (EIP-191).\n        \"\"\"\n        message_hash = self.get_message_hash(message)\n        return self.eth_adapter.sign_message(message_hash)\n\n    def is_valid_signature(\n        self, message_hash: str | bytes, signature: str | bytes\n    ) -&gt; bool:\n        \"\"\"\n        Checks if a signature is valid for a given message hash using EIP-1271.\n        \"\"\"\n        if isinstance(message_hash, str):\n            message_hash = HexBytes(message_hash)\n        if isinstance(signature, str):\n            signature = HexBytes(signature)\n\n        try:\n            # isValidSignature(bytes32 _data, bytes memory _signature)\n            # returns (bytes4)\n            result = self.contract.functions.isValidSignature(\n                message_hash, signature\n            ).call()\n            return HexBytes(result) == HexBytes(EIP1271_MAGIC_VALUE)\n        except Exception:\n            return False\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.add_prevalidated_signature","title":"<code>add_prevalidated_signature(safe_transaction, owner_address)</code>","text":"<p>Adds a pre-validated signature for a given owner. v=1, r=owner, s=0.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def add_prevalidated_signature(\n    self, safe_transaction: SafeTransaction, owner_address: str\n) -&gt; SafeTransaction:\n    \"\"\"\n    Adds a pre-validated signature for a given owner.\n    v=1, r=owner, s=0.\n    \"\"\"\n    owner_address = self.eth_adapter.to_checksum_address(owner_address)\n    # Signature: r(32) + s(32) + v(1)\n    # r = owner address, padded to 32 bytes\n    # s = 0, padded to 32 bytes\n    # v = 1\n    r = owner_address.lower().replace(\"0x\", \"\").zfill(64)\n    s = \"0\" * 64\n    v = \"01\"\n    signature = \"0x\" + r + s + v\n    safe_transaction.add_signature(owner_address, signature)\n    return safe_transaction\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.add_signature","title":"<code>add_signature(safe_transaction, owner_address, signature)</code>","text":"<p>Adds a signature to a Safe transaction.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def add_signature(\n    self, safe_transaction: SafeTransaction, owner_address: str, signature: str\n) -&gt; SafeTransaction:\n    \"\"\"\n    Adds a signature to a Safe transaction.\n    \"\"\"\n    owner_address = self.eth_adapter.to_checksum_address(owner_address)\n    safe_transaction.add_signature(owner_address, signature)\n    return safe_transaction\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.approve_hash","title":"<code>approve_hash(hash_to_approve)</code>","text":"<p>Approves a hash on-chain.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def approve_hash(self, hash_to_approve: str) -&gt; str:\n    \"\"\"\n    Approves a hash on-chain.\n    \"\"\"\n    try:\n        params: SafeApproveHashParams = {\"hashToApprove\": HexBytes(hash_to_approve)}\n        tx_hash = self.contract.functions.approveHash(**params).transact(\n            {\"from\": self.eth_adapter.get_signer_address()}\n        )\n        return cast(str, tx_hash.hex())\n    except Exception as e:\n        raise handle_contract_error(e) from e\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.check_signatures","title":"<code>check_signatures(safe_transaction)</code>","text":"<p>Checks if the signatures on the transaction are valid. Raises an error if signatures are invalid.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def check_signatures(self, safe_transaction: SafeTransaction) -&gt; None:\n    \"\"\"\n    Checks if the signatures on the transaction are valid.\n    Raises an error if signatures are invalid.\n    \"\"\"\n    tx_hash = self.get_transaction_hash(safe_transaction)\n    # Convert hex string hash to bytes\n    tx_hash_bytes = HexBytes(tx_hash)\n\n    self.contract.functions.checkSignatures(\n        tx_hash_bytes,\n        HexBytes(safe_transaction.data.data),\n        safe_transaction.sorted_signatures_bytes,\n    ).call()\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.create","title":"<code>create(eth_adapter, safe_address, chain_id=None)</code>  <code>classmethod</code>","text":"<p>Factory method to create a Safe instance.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>@classmethod\ndef create(\n    cls, eth_adapter: EthAdapter, safe_address: str, chain_id: int | None = None\n) -&gt; \"Safe\":\n    \"\"\"\n    Factory method to create a Safe instance.\n    \"\"\"\n    return cls(eth_adapter, safe_address, chain_id)\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.create_transaction","title":"<code>create_transaction(transaction_data)</code>","text":"<p>Creates a Safe transaction ready to be signed.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def create_transaction(\n    self, transaction_data: SafeTransactionData\n) -&gt; SafeTransaction:\n    \"\"\"\n    Creates a Safe transaction ready to be signed.\n    \"\"\"\n    if transaction_data.nonce is None:\n        transaction_data.nonce = self.get_nonce()\n\n    return SafeTransaction(data=transaction_data)\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.estimate_safe_transaction_gas","title":"<code>estimate_safe_transaction_gas(safe_transaction)</code>","text":"<p>Estimates the total gas (ETH gas) required to execute the Safe transaction. Uses eth_estimateGas on the execTransaction function.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def estimate_safe_transaction_gas(self, safe_transaction: SafeTransaction) -&gt; int:\n    \"\"\"\n    Estimates the total gas (ETH gas) required to execute the Safe transaction.\n    Uses eth_estimateGas on the execTransaction function.\n    \"\"\"\n    params: SafeExecTransactionParams = {\n        \"to\": safe_transaction.data.to,\n        \"value\": safe_transaction.data.value,\n        \"data\": HexBytes(safe_transaction.data.data),\n        \"operation\": safe_transaction.data.operation,\n        \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n        \"baseGas\": safe_transaction.data.base_gas,\n        \"gasPrice\": safe_transaction.data.gas_price,\n        \"gasToken\": safe_transaction.data.gas_token,\n        \"refundReceiver\": safe_transaction.data.refund_receiver,\n        \"signatures\": safe_transaction.sorted_signatures_bytes,\n    }\n\n    return cast(\n        int,\n        self.contract.functions.execTransaction(**params).estimate_gas(\n            {\"from\": self.eth_adapter.get_signer_address()}\n        ),\n    )\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.estimate_transaction_gas","title":"<code>estimate_transaction_gas(safe_transaction)</code>","text":"<p>Estimates the internal gas required for a Safe transaction (safeTxGas). Uses the Safe contract's requiredTxGas function.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def estimate_transaction_gas(self, safe_transaction: SafeTransaction) -&gt; int:\n    \"\"\"\n    Estimates the internal gas required for a Safe transaction (safeTxGas).\n    Uses the Safe contract's requiredTxGas function.\n    \"\"\"\n    params: SafeRequiredTxGasParams = {\n        \"to\": safe_transaction.data.to,\n        \"value\": safe_transaction.data.value,\n        \"data\": HexBytes(safe_transaction.data.data),\n        \"operation\": safe_transaction.data.operation,\n        \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n        \"baseGas\": safe_transaction.data.base_gas,\n        \"gasPrice\": safe_transaction.data.gas_price,\n        \"gasToken\": safe_transaction.data.gas_token,\n        \"refundReceiver\": safe_transaction.data.refund_receiver,\n        \"signatures\": safe_transaction.sorted_signatures_bytes,\n    }\n    return cast(\n        int,\n        self.contract.functions.requiredTxGas(**params).call(),\n    )\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.execute_transaction","title":"<code>execute_transaction(safe_transaction, wait_for_receipt=False, gas=None)</code>","text":"<p>Executes a Safe transaction.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def execute_transaction(\n    self,\n    safe_transaction: SafeTransaction,\n    wait_for_receipt: bool = False,\n    gas: int | None = None,\n) -&gt; str:\n    \"\"\"\n    Executes a Safe transaction.\n    \"\"\"\n    # Sort signatures\n    sorted_signatures = safe_transaction.sorted_signatures_bytes\n\n    try:\n        params: SafeExecTransactionParams = {\n            \"to\": safe_transaction.data.to,\n            \"value\": safe_transaction.data.value,\n            \"data\": HexBytes(safe_transaction.data.data),\n            \"operation\": safe_transaction.data.operation,\n            \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n            \"baseGas\": safe_transaction.data.base_gas,\n            \"gasPrice\": safe_transaction.data.gas_price,\n            \"gasToken\": safe_transaction.data.gas_token,\n            \"refundReceiver\": safe_transaction.data.refund_receiver,\n            \"signatures\": sorted_signatures,\n        }\n\n        tx_params: dict[str, Any] = {\"from\": self.eth_adapter.get_signer_address()}\n        if gas is not None:\n            tx_params[\"gas\"] = gas\n\n        tx_hash_hex = self.contract.functions.execTransaction(**params).transact(\n            tx_params\n        )\n\n        tx_hash = cast(str, tx_hash_hex.hex())\n\n        if wait_for_receipt:\n            self.wait_for_transaction(tx_hash)\n\n        return tx_hash\n    except Exception as e:\n        raise handle_contract_error(e) from e\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_address","title":"<code>get_address()</code>","text":"<p>Returns the address of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_address(self) -&gt; str:\n    \"\"\"\n    Returns the address of the Safe.\n    \"\"\"\n    return self.safe_address\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_balance","title":"<code>get_balance()</code>","text":"<p>Returns the ETH balance of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_balance(self) -&gt; int:\n    \"\"\"\n    Returns the ETH balance of the Safe.\n    \"\"\"\n    return self.eth_adapter.get_balance(self.safe_address)\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_domain_separator","title":"<code>get_domain_separator()</code>","text":"<p>Returns the EIP-712 domain separator of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_domain_separator(self) -&gt; str:\n    \"\"\"\n    Returns the EIP-712 domain separator of the Safe.\n    \"\"\"\n    return cast(str, self.contract.functions.domainSeparator().call().hex())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_message_hash","title":"<code>get_message_hash(message)</code>","text":"<p>Returns the safe message hash for a given message.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_message_hash(self, message: str | bytes) -&gt; str:\n    \"\"\"\n    Returns the safe message hash for a given message.\n    \"\"\"\n    if isinstance(message, str):\n        if message.startswith(\"0x\"):\n            message_bytes = HexBytes(message)\n        else:\n            message_bytes = HexBytes(message.encode(\"utf-8\"))\n    elif isinstance(message, bytes):\n        message_bytes = HexBytes(message)\n    else:\n        raise TypeError(\"message must be str or bytes\")\n\n    # keccak256(message)\n    from eth_hash.auto import keccak\n\n    message_hash = keccak(message_bytes)\n\n    result = self.contract.functions.getMessageHash(message_hash).call().hex()\n    if not result.startswith(\"0x\"):\n        result = \"0x\" + result\n    return cast(str, result)\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_nonce","title":"<code>get_nonce()</code>","text":"<p>Returns the current nonce of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_nonce(self) -&gt; int:\n    \"\"\"\n    Returns the current nonce of the Safe.\n    \"\"\"\n    return cast(int, self.contract.functions.nonce().call())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_owners","title":"<code>get_owners()</code>","text":"<p>Returns the owners of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_owners(self) -&gt; list[str]:\n    \"\"\"\n    Returns the owners of the Safe.\n    \"\"\"\n    return cast(list[str], self.contract.functions.getOwners().call())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_threshold","title":"<code>get_threshold()</code>","text":"<p>Returns the threshold of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_threshold(self) -&gt; int:\n    \"\"\"\n    Returns the threshold of the Safe.\n    \"\"\"\n    return cast(int, self.contract.functions.getThreshold().call())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_transaction_hash","title":"<code>get_transaction_hash(safe_transaction)</code>","text":"<p>Returns the hash of the Safe transaction.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_transaction_hash(self, safe_transaction: SafeTransaction) -&gt; str:\n    \"\"\"\n    Returns the hash of the Safe transaction.\n    \"\"\"\n    params: SafeGetTransactionHashParams = {\n        \"to\": safe_transaction.data.to,\n        \"value\": safe_transaction.data.value,\n        \"data\": HexBytes(safe_transaction.data.data),\n        \"operation\": safe_transaction.data.operation,\n        \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n        \"baseGas\": safe_transaction.data.base_gas,\n        \"gasPrice\": safe_transaction.data.gas_price,\n        \"gasToken\": safe_transaction.data.gas_token,\n        \"refundReceiver\": safe_transaction.data.refund_receiver,\n        \"_nonce\": (\n            safe_transaction.data.nonce\n            if safe_transaction.data.nonce is not None\n            else 0\n        ),\n    }\n\n    return cast(\n        str,\n        self.contract.functions.getTransactionHash(**params).call().hex(),\n    )\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.get_version","title":"<code>get_version()</code>","text":"<p>Returns the version of the Safe contract.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def get_version(self) -&gt; str:\n    \"\"\"\n    Returns the version of the Safe contract.\n    \"\"\"\n    return cast(str, self.contract.functions.VERSION().call())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.is_owner","title":"<code>is_owner(address)</code>","text":"<p>Checks if an address is an owner of the Safe.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def is_owner(self, address: str) -&gt; bool:\n    \"\"\"\n    Checks if an address is an owner of the Safe.\n    \"\"\"\n    params: SafeIsOwnerParams = {\"owner\": address}\n    return cast(bool, self.contract.functions.isOwner(**params).call())\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.is_valid_signature","title":"<code>is_valid_signature(message_hash, signature)</code>","text":"<p>Checks if a signature is valid for a given message hash using EIP-1271.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def is_valid_signature(\n    self, message_hash: str | bytes, signature: str | bytes\n) -&gt; bool:\n    \"\"\"\n    Checks if a signature is valid for a given message hash using EIP-1271.\n    \"\"\"\n    if isinstance(message_hash, str):\n        message_hash = HexBytes(message_hash)\n    if isinstance(signature, str):\n        signature = HexBytes(signature)\n\n    try:\n        # isValidSignature(bytes32 _data, bytes memory _signature)\n        # returns (bytes4)\n        result = self.contract.functions.isValidSignature(\n            message_hash, signature\n        ).call()\n        return HexBytes(result) == HexBytes(EIP1271_MAGIC_VALUE)\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.sign_message","title":"<code>sign_message(message)</code>","text":"<p>Signs a message hash using the current signer. Returns the signature using eth_sign (EIP-191).</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def sign_message(self, message: str | bytes) -&gt; str:\n    \"\"\"\n    Signs a message hash using the current signer.\n    Returns the signature using eth_sign (EIP-191).\n    \"\"\"\n    message_hash = self.get_message_hash(message)\n    return self.eth_adapter.sign_message(message_hash)\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.sign_transaction","title":"<code>sign_transaction(safe_transaction, method='eth_sign_typed_data')</code>","text":"<p>Signs a Safe transaction with the current signer. Supported methods: \"eth_sign_typed_data\" (EIP-712), \"eth_sign\" (legacy).</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def sign_transaction(\n    self, safe_transaction: SafeTransaction, method: str = \"eth_sign_typed_data\"\n) -&gt; SafeTransaction:\n    \"\"\"\n    Signs a Safe transaction with the current signer.\n    Supported methods: \"eth_sign_typed_data\" (EIP-712), \"eth_sign\" (legacy).\n    \"\"\"\n    signer_address = self.eth_adapter.get_signer_address()\n    if not signer_address:\n        raise ValueError(\"No signer configured in the adapter\")\n\n    chain_id = self.eth_adapter.get_chain_id()\n\n    if method == \"eth_sign_typed_data\":\n        eip712_data = safe_transaction.data.get_eip712_data(\n            chain_id, self.safe_address\n        )\n        signature = self.eth_adapter.sign_typed_data(eip712_data)\n    elif method == \"eth_sign\":\n        tx_hash = self.get_transaction_hash(safe_transaction)\n        signature = self.eth_adapter.sign_message(tx_hash)\n        # Adjust v for eth_sign: v += 4\n        # Signature is r(32) + s(32) + v(1)\n        # We need to parse it, adjust v, and reconstruct\n        sig_bytes = HexBytes(signature)\n        r = sig_bytes[:32]\n        s = sig_bytes[32:64]\n        v = sig_bytes[64]\n        v += 4\n        signature = (r + s + bytes([v])).hex()\n    else:\n        raise ValueError(f\"Unsupported signing method: {method}\")\n\n    safe_transaction.add_signature(signer_address, signature)\n    return safe_transaction\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.simulate_transaction","title":"<code>simulate_transaction(safe_transaction)</code>","text":"<p>Simulates the transaction using eth_call. Returns True if the transaction would succeed, False otherwise.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def simulate_transaction(self, safe_transaction: SafeTransaction) -&gt; bool:\n    \"\"\"\n    Simulates the transaction using eth_call.\n    Returns True if the transaction would succeed, False otherwise.\n    \"\"\"\n    try:\n        params: SafeExecTransactionParams = {\n            \"to\": safe_transaction.data.to,\n            \"value\": safe_transaction.data.value,\n            \"data\": HexBytes(safe_transaction.data.data),\n            \"operation\": safe_transaction.data.operation,\n            \"safeTxGas\": safe_transaction.data.safe_tx_gas,\n            \"baseGas\": safe_transaction.data.base_gas,\n            \"gasPrice\": safe_transaction.data.gas_price,\n            \"gasToken\": safe_transaction.data.gas_token,\n            \"refundReceiver\": safe_transaction.data.refund_receiver,\n            \"signatures\": safe_transaction.sorted_signatures_bytes,\n        }\n\n        # Use call() to simulate\n        success = self.contract.functions.execTransaction(**params).call(\n            {\"from\": self.eth_adapter.get_signer_address()}\n        )\n\n        return cast(bool, success)\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/safe/#safe_kit.safe.Safe.wait_for_transaction","title":"<code>wait_for_transaction(tx_hash, timeout=120)</code>","text":"<p>Waits for a transaction receipt.</p> Source code in <code>safe_kit/safe.py</code> <pre><code>def wait_for_transaction(self, tx_hash: str, timeout: int = 120) -&gt; Any:\n    \"\"\"\n    Waits for a transaction receipt.\n    \"\"\"\n    return self.eth_adapter.wait_for_transaction_receipt(tx_hash, timeout=timeout)\n</code></pre>"},{"location":"api/types/","title":"Types","text":""},{"location":"api/types/#safe_kit.types","title":"<code>safe_kit.types</code>","text":""},{"location":"api/types/#safe_kit.types.SafeAccountConfig","title":"<code>SafeAccountConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for deploying a new Safe.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeAccountConfig(BaseModel):\n    \"\"\"\n    Configuration for deploying a new Safe.\n    \"\"\"\n\n    owners: list[str]\n    threshold: int\n    to: str = \"0x0000000000000000000000000000000000000000\"\n    data: str = \"0x\"\n    fallback_handler: str = \"0x0000000000000000000000000000000000000000\"\n    payment_token: str = \"0x0000000000000000000000000000000000000000\"\n    payment: int = 0\n    payment_receiver: str = \"0x0000000000000000000000000000000000000000\"\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeCollectibleResponse","title":"<code>SafeCollectibleResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>NFT/Collectible owned by a Safe.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeCollectibleResponse(BaseModel):\n    \"\"\"NFT/Collectible owned by a Safe.\"\"\"\n\n    address: str\n    token_name: str = Field(alias=\"tokenName\")\n    token_symbol: str = Field(alias=\"tokenSymbol\")\n    logo_uri: str = Field(alias=\"logoUri\")\n    id: str\n    uri: str | None\n    name: str | None\n    description: str | None\n    image_uri: str | None = Field(alias=\"imageUri\")\n    metadata: dict[str, Any] | None\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeCreationInfoResponse","title":"<code>SafeCreationInfoResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about Safe creation.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeCreationInfoResponse(BaseModel):\n    \"\"\"Information about Safe creation.\"\"\"\n\n    created: str\n    creator: str\n    transaction_hash: str = Field(alias=\"transactionHash\")\n    factory_address: str = Field(alias=\"factoryAddress\")\n    master_copy: str = Field(alias=\"masterCopy\")\n    setup_data: str | None = Field(alias=\"setupData\")\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeDataDecoderResponse","title":"<code>SafeDataDecoderResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Decoded data from the Safe Transaction Service.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeDataDecoderResponse(BaseModel):\n    \"\"\"Decoded data from the Safe Transaction Service.\"\"\"\n\n    method: str\n    parameters: list[dict[str, Any]] | None\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeDelegateResponse","title":"<code>SafeDelegateResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Delegate for a Safe.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeDelegateResponse(BaseModel):\n    \"\"\"Delegate for a Safe.\"\"\"\n\n    safe: str | None\n    delegate: str\n    delegator: str\n    label: str\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeInfoResponse","title":"<code>SafeInfoResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a Safe from the Transaction Service.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeInfoResponse(BaseModel):\n    \"\"\"Information about a Safe from the Transaction Service.\"\"\"\n\n    address: str\n    nonce: int\n    threshold: int\n    owners: list[str]\n    master_copy: str = Field(alias=\"masterCopy\")\n    modules: list[str]\n    fallback_handler: str = Field(alias=\"fallbackHandler\")\n    guard: str\n    version: str | None\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeTokenResponse","title":"<code>SafeTokenResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a Token.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeTokenResponse(BaseModel):\n    \"\"\"Information about a Token.\"\"\"\n\n    address: str\n    name: str\n    symbol: str\n    decimals: int\n    logo_uri: str | None = Field(alias=\"logoUri\")\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeTransaction","title":"<code>SafeTransaction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing a complete Safe transaction including signatures.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeTransaction(BaseModel):\n    \"\"\"\n    Model representing a complete Safe transaction including signatures.\n    \"\"\"\n\n    data: SafeTransactionData\n    signatures: dict[str, str] = Field(default_factory=dict)\n\n    def add_signature(self, owner: str, signature: str) -&gt; None:\n        self.signatures[owner] = signature\n\n    @property\n    def sorted_signatures_bytes(self) -&gt; bytes:\n        from hexbytes import HexBytes\n\n        # Sort by owner address\n        sorted_owners = sorted(self.signatures.keys(), key=lambda x: int(x, 16))\n        signature_bytes = b\"\"\n        for owner in sorted_owners:\n            signature_bytes += HexBytes(self.signatures[owner])\n        return signature_bytes\n</code></pre>"},{"location":"api/types/#safe_kit.types.SafeTransactionData","title":"<code>SafeTransactionData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing the data of a Safe transaction.</p> Source code in <code>safe_kit/types.py</code> <pre><code>class SafeTransactionData(BaseModel):\n    \"\"\"\n    Model representing the data of a Safe transaction.\n    \"\"\"\n\n    to: str\n    value: int\n    data: str\n    operation: int = 0\n    safe_tx_gas: int = 0\n    base_gas: int = 0\n    gas_price: int = 0\n    gas_token: str = \"0x0000000000000000000000000000000000000000\"\n    refund_receiver: str = \"0x0000000000000000000000000000000000000000\"\n    nonce: int | None = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def get_eip712_data(self, chain_id: int, safe_address: str) -&gt; dict[str, Any]:\n        from hexbytes import HexBytes\n\n        return {\n            \"types\": {\n                \"EIP712Domain\": [\n                    {\"name\": \"chainId\", \"type\": \"uint256\"},\n                    {\"name\": \"verifyingContract\", \"type\": \"address\"},\n                ],\n                \"SafeTx\": [\n                    {\"name\": \"to\", \"type\": \"address\"},\n                    {\"name\": \"value\", \"type\": \"uint256\"},\n                    {\"name\": \"data\", \"type\": \"bytes\"},\n                    {\"name\": \"operation\", \"type\": \"uint8\"},\n                    {\"name\": \"safeTxGas\", \"type\": \"uint256\"},\n                    {\"name\": \"baseGas\", \"type\": \"uint256\"},\n                    {\"name\": \"gasPrice\", \"type\": \"uint256\"},\n                    {\"name\": \"gasToken\", \"type\": \"address\"},\n                    {\"name\": \"refundReceiver\", \"type\": \"address\"},\n                    {\"name\": \"nonce\", \"type\": \"uint256\"},\n                ],\n            },\n            \"primaryType\": \"SafeTx\",\n            \"domain\": {\n                \"chainId\": chain_id,\n                \"verifyingContract\": safe_address,\n            },\n            \"message\": {\n                \"to\": self.to,\n                \"value\": self.value,\n                \"data\": HexBytes(self.data),\n                \"operation\": self.operation,\n                \"safeTxGas\": self.safe_tx_gas,\n                \"baseGas\": self.base_gas,\n                \"gasPrice\": self.gas_price,\n                \"gasToken\": self.gas_token,\n                \"refundReceiver\": self.refund_receiver,\n                \"nonce\": self.nonce if self.nonce is not None else 0,\n            },\n        }\n</code></pre>"}]}