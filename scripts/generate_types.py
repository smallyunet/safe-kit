import os
import sys
from typing import Any

# Add the project root to sys.path so we can import safe_kit
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from safe_kit.abis import ERC20_ABI, ERC721_ABI, SAFE_ABI, SAFE_PROXY_FACTORY_ABI  # noqa: E402, I001

TYPE_MAPPING = {
    "address": "str",
    "uint256": "int",
    "uint8": "int",
    "uint": "int",
    "bool": "bool",
    "bytes": "bytes",
    "bytes32": "bytes",
    "string": "str",
    "address payable": "str",
}

def get_python_type(solidity_type: str) -> str:
    if solidity_type.endswith("[]"):
        base_type = solidity_type[:-2]
        return f"list[{get_python_type(base_type)}]"
    
    if solidity_type.startswith("enum"):
        return "int"
        
    return TYPE_MAPPING.get(solidity_type, "Any")

def generate_typed_dict(name: str, params: list[dict[str, Any]]) -> str:
    if not params:
        return ""
        
    lines = [f"class {name}(TypedDict):"]
    for param in params:
        param_name = param["name"]
        # Handle empty names in return values or inputs
        if not param_name:
            continue
        # Handle python keywords
        if param_name in ["from", "class", "return", "pass", "import"]:
            param_name = f"{param_name}_"
            
        py_type = get_python_type(param["type"])
        lines.append(f"    {param_name}: {py_type}")
    
    if len(lines) == 1:
        # No named parameters
        return ""
        
    return "\n".join(lines) + "\n\n"

def process_abi(abi: list[dict[str, Any]], prefix: str) -> str:
    output = ""
    seen_names = set()
    
    for item in abi:
        if item.get("type") != "function":
            continue
            
        fn_name = item["name"]
        # Capitalize first letter
        fn_name_cap = fn_name[0].upper() + fn_name[1:]
        
        # Handle overloads (simple approach: skip duplicates or append index)
        # For now, we'll just skip if we've seen it, which isn't perfect but works for
        # simple cases
        if fn_name in seen_names:
            continue
        seen_names.add(fn_name)
        
        # Generate Params
        params_name = f"{prefix}{fn_name_cap}Params"
        output += generate_typed_dict(params_name, item.get("inputs", []))
        
        # Generate Return
        # Only if outputs have names, otherwise it's usually a tuple or single value
        # Web3.py returns a single value if one output, tuple if multiple.
        # If outputs are named, we might want a TypedDict, but Web3.py returns
        # tuples/values, not dicts.
        # So generating TypedDict for return values might be misleading unless we wrap
        # the return.
        # For now, let's stick to Params which are useful for calling functions.
        
    return output

def main() -> None:
    output_file = os.path.abspath(
        os.path.join(os.path.dirname(__file__), "..", "safe_kit", "contract_types.py")
    )
    
    content = """# This file is automatically generated by scripts/generate_types.py
# Do not edit manually.

from typing import Any, TypedDict  # noqa: F401

"""
    
    content += process_abi(SAFE_ABI, "Safe")
    content += process_abi(SAFE_PROXY_FACTORY_ABI, "SafeProxyFactory")
    content += process_abi(ERC20_ABI, "Erc20")
    content += process_abi(ERC721_ABI, "Erc721")
    
    with open(output_file, "w") as f:
        f.write(content)
    
    print(f"Generated types in {output_file}")

if __name__ == "__main__":
    main()
